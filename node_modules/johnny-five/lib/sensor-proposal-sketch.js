(function() {
var priv = new WeakMap(),
    // Enumerable device sensor instance list
    sensors = [];

function EventTarget() {
  priv.set( this, {
    events: {}
  });
}
EventTarget.prototype.on = function( type, fn ) {
  var events = priv.get( this ).events;

  if ( !events[ type ] ) {
    events[ type ] = [];
  }
  events[ type ].push( fn );

  return this;
};
EventTarget.prototype.off = function( type ) {
  priv.get( this ).events[ type ] = [];
  return this;
};
EventTarget.prototype.emit = function( type /*, args */ ) {
  var events, event, queue, fn,
      args = [].slice.call( arguments, 1 );

  events = priv.get( this ).events;

  for ( event in events ) {
    queue = events[ event ];
    if ( queue.length ) {
      queue = queue.slice();
      while ( fn = queue.shift() ) {
        fn.apply( this, [{ timestamp: Date.now() }].concat( args ) );
      }
    }
  }
  return this;
}

function scale( value ) {
  return ( value - this.min ) * ( this.range[1] - this.range[0] ) /
          ( this.max - this.min ) + this.range[0];
}

function Sensor( opts, key ) {
  if ( key !== priv ) {
    throw new Error("Illegal Constructor");
  }
  EventTarget.call( this );

  // Simulate inter-process boundary crossing
  priv.get( this ).value = 0;

  Object.defineProperties( this, {
    min: {
      value: opts.min !== undefined ? opts.min : 0,
      configurable: true,
      enumerable: true
    },
    max: {
      value: opts.max !== undefined ? opts.max : 1023,
      configurable: true,
      enumerable: true
    },
    range: {
      value: opts.range || [ /* default to own min and max */ this.min, this.max ]
    },
    value: {
      get: function() {
        return scale.call( this, priv.get( this ).value );
      },
      configurable: true,
      enumerable: true
    }
  });

  // Add to simulated system device sensor list
  sensors.push(this);
}

Sensor.prototype = Object.create( EventTarget.prototype );
Sensor.prototype.constructor = Sensor;

Sensor.prototype.scale = function( lower, upper ) {
  this.range[0] = lower;
  this.range[1] = upper;
  return this;
};

/*
    Sensor.Temperature

    Celcius, Fahrenheit

    @param opts object { unit: C | F }
 */

Sensor.Temperature = function Temperature( opts ) {
  var range = Sensor.Temperature[ opts.unit || "C" ];

  Sensor.call( this, {
    min: 0,
    max: 1023,
    // Sensor will assign [min, max] to range
    range: [
      range[0],
      range[1]
    ]
  }, priv);

  // Set the value with an initial reading from the device sensor
  // This will be room temperature, for illustration
  priv.get( this ).value = 324;

  Object.defineProperties( this, {
    value: {
      get: function() {
        return scale.call( this, priv.get( this ).value );
      },
      enumerable: true
    }
  });
};

Object.defineProperties( Sensor.Temperature, {
  C: {
    value: [ -40, 150 ],
    writable: false,
    configurable: false,
    enumerable: true
  },
  F: {
    value: [ -40, 302 ],
    writable: false,
    configurable: false,
    enumerable: true
  }
});

Sensor.Temperature.prototype = Object.create( Sensor.prototype );
Sensor.Temperature.prototype.constructor = Sensor.Temperature;


Sensor.Temperature.prototype.unit = function( unit ) {
  var range = Sensor.Temperature[ unit || "C" ];

  this.min = this.range[0] = range[0];
  this.max = this.range[1] = range[1];

  return this;
};

// Overwrite scale as a no-op
// Temperature Sensors are scaled internally
Sensor.Temperature.prototype.scale = function() {
  return this;
};


/*
    Sensor.Light

    Lux

    @param opts object { range: [ lower, upper ] }
 */

Sensor.Light = function Light( opts ) {
  Sensor.call( this, {
    min: 0,
    max: 1023,
    // If undefined, Sensor will assign [min, max]
    range: [
      0,  25000
    ]
  }, priv );

  // Set the value with an initial reading from the device sensor
  // This will be Full Daylight, for illustration
  priv.get( this ).value = 409.2;

  Object.defineProperties( this, {
    value: {
      get: function() {
        return scale.call( this, priv.get( this ).value );
      },
      enumerable: true
    }
  });
};

Sensor.Light.prototype = Object.create( Sensor.prototype );
Sensor.Light.prototype.constructor = Sensor.Light;



/*
    Sensor.Proximity

    cm

    @param opts object { range: [ lower, upper ] }
 */

Sensor.Proximity = function Proximity( opts ) {
  Sensor.call( this, {
    min: 0,
    max: 1023,
    // If undefined, Sensor will assign [min, max]
    range: [
      0,  609.6
    ]
  }, priv );

  // Set the value with an initial reading from the device sensor
  // This will be 10cm, for illustration
  priv.get( this ).value = 18;

  Object.defineProperties( this, {
    value: {
      get: function() {
        return scale.call( this, priv.get( this ).value );
      },
      enumerable: true
    }
  });
};

Sensor.Proximity.prototype = Object.create( Sensor.prototype );
Sensor.Proximity.prototype.constructor = Sensor.Proximity;



// Expose the Sensor API.
global.Sensor = Sensor;


// ------------------------------------------------------------
// For demonstration/illustration purpose only
// Simulate Device's sensor read loop
var last = new Date().getSeconds();
setInterval(function() {
  sensors.forEach(function( sensor ) {
    var now, max, min,

    min = 0;
    max = 1023;
    // Simulate a sensors that mostly stay the same... Every ten seconds they
    // will change, so we can do some kind of "change" example
    now = new Date().getSeconds();

    if ( now !== last && now % 10 === 0 ) {
      last = now;
      priv.get( sensor ).value = Math.floor(Math.random() * (max - min + 1)) + min;
      sensor.emit("change");
    }
    // sensor.emit( "data" );
  });
}, 0);
// IIFE to simulate runtime "setup"
}());

// User code...

var illegal, temp, light, prox;

// Just a test of the base Sensor
try {
  illegal = new Sensor();
} catch ( e ) {
  console.log( e.message === "Illegal Constructor" );
}


temp = new Sensor.Temperature({
  unit: "C"
});
console.log( "temp", temp.value, Math.floor(temp.value) === 20, temp );

temp.on("change", function() {
  console.log( "temp change", this.value );
});


light = new Sensor.Light();
console.log( "light", light.value, Math.floor(light.value) === 10000, light );

light.scale(0, 10).on("change", function() {
  console.log( "light change", this.value );
});


prox = new Sensor.Proximity();
console.log( "prox", prox.value, Math.floor(prox.value) === 10, prox );

prox.on("change", function() {
  console.log( "prox change", this.value );
});
