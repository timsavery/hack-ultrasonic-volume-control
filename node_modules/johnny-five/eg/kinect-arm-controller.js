var five = require("../lib/johnny-five.js"),
    OpenNI = require("openni"),
    kinect;

Object.mixin = function( receiver, supplier ) {
  return Object.getOwnPropertyNames( supplier ).reduce(function( receiver, property ) {
    return Object.defineProperty(
      receiver, property, Object.getOwnPropertyDescriptor( supplier, property )
    );
  }, receiver );
};

function Point( initialiser ) {
  [ Point.DEFAULTS, initialiser || {} ].reduce( Object.mixin, this );
}

Point.DEFAULTS = {
  x: 0, y: 0, z: 0
};

Point.prototype.square = function() {
  return (this.x * this.x) + (this.y * this.y) + (this.z * this.z);
};

Point.prototype.magnitude = function() {
  return Math.sqrt( this.square() );
};

Point.prototype.angleTo = function( point ) {
  var theta, dy, dx;

  dy = point.y - this.y;
  dx = point.x - this.x;
  theta = Math.atan2( dy, dx );
  // theta *= 180 / Math.PI;
  theta *= 360 / Math.PI;

  if ( theta < 0 ) {
    theta +=
  }

  return theta;
};


function Skeleton( initialiser ) {
  [ Skeleton.DEFAULTS, initialiser || {} ].reduce( Object.mixin, this );

  Skeleton.Joints.forEach(function( joint ) {
    this.points[ joint ] = new Point();

    this.kinect.on( joint, function( id, x, y, z ) {
      var point = this.points[ joint ];
      if ( point ) {
        point.x = x;
        point.y = y;
        point.z = z;
      }
    }.bind(this));
  }, this);

  Skeletons.push( this );
}

Skeleton.DEFAULTS = {
  points: {}
};

Skeleton.Joints = [
  "head",
  "neck",
  // "torso",
  // "waist",
  "left_shoulder",
  "left_elbow",
  "left_hand",
  "right_shoulder",
  "right_elbow",
  "right_hand",
  "left_hip",
  "left_knee",
  "left_foot",
  "right_hip",
  "right_knee",
  "right_foot"
];

var Skeletons  = [];


five.Board().on("ready", function() {
  var defs, servos;

  // http://www.ranchbots.com/robot_arm/images/arm_diagram.jpg
  defs = [
    // Pivot/Rotator
    { id: "rotator", pin:  6, range: [  10, 170 ], startAt: 90 },
    // Shoulder
    { id: "shoulder", pin:  9, range: [ 0, 180 ], startAt: 90 },
    // Elbow
    { id: "elbow", pin: 10, range: [  0, 180 ], startAt: 90 },
    // Wrist
    { id: "wrist", pin: 11, range: [  10, 170 ], startAt: 40 },
    // Grip
    { id: "claw", pin: 12, range: [  10, 170 ], startAt: 0 }
  ];

  // Reduce the des array into an object of servo instances,
  // where the servo id is the property name
  servos = defs.reduce(function( accum, def ) {
    return (accum[ def.id ] = five.Servo( def )) && accum;
  }, {});

  // Make servos accessible by name in the REPL
  this.repl.inject( servos );

  kinect = OpenNI();
  // Logging from Kinect/OpenNI
  [
    "newuser",
    "lostuser",
    "posedetected",
    "calibrationstart",
    "calibrationsuccess",
    "calibrationfail"
  ].forEach(function( type ) {
    kinect.on( type , function( id ) {
      console.log( "%s (%d)", type, id );

      if ( type === "newuser" ) {

        if ( Skeletons.length === 0 ) {
          new Skeleton({
            kinect: kinect
          });
        } else {
          Skeletons[0].inFrame = true;
        }
      }
      if ( type === "lostuser" ) {
        console.log( "OUT OF FRAME" );
        if ( Skeletons.length ) {
          Skeletons[0].inFrame = false;
        }
      }
    });
  });

  var last = Date.now();


  void function output() {
    process.nextTick( output );

    var shoulder, elbow, hand, points, s, e;

    if ( Skeletons.length && (points = Skeletons[0].points) ) {
      if ( points.right_shoulder && points.right_elbow && points.right_hand ) {
        shoulder = points.right_shoulder;
        elbow = points.right_elbow;
        hand = points.right_hand;

        // process.stdout.write(
        //   [
        //     "shoulder -> elbow: " + Math.round( elbow.angleTo(shoulder) ),
        //     "elbow -> hand: " + Math.round( elbow.angleTo(hand) )
        //   ].join(", ") + "\r"
        // );
        s = Math.round( elbow.angleTo(shoulder) );
        // s = five.Fn.scale( s, -180, 180, 0, 180 );
        //five.Fn.scale( Math.round( shoulder.angleTo(elbow) ), 180, 0, 0, 180 );

        if ( Date.now() > (last + 100) ) {
          last = Date.now();

          console.log( s );

          // servos.shoulder.move( s );

        }
        // servos.elbow.move( Math.round( elbow.angleTo(hand) ) );
      }
    }
  }();


// References
// https://github.com/OpenNI/OpenNI/blob/master/Include/XnCppWrapper.h
// http://www.mrtmrcn.com/en/post/2011/11/08/Kinect-Part-5-Kinect-Skeleton-Tracking.aspx
// http://code.google.com/p/bikinect/source/browse/trunk/MappInect/Skeleton.pde
// https://github.com/Sensebloom/OSCeleton-examples/blob/master/processing/Stickmanetic/Stickmanetic.pde
// http://www.pcl-users.org/openni-device-h-47-26-fatal-error-XnCppWrapper-h-No-such-file-or-directory-td3174297.html
// http://kinectcar.ronsper.com/docs/openni/_xn_cpp_wrapper_8h_source.html

});
