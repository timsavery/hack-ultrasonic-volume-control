var toBin = require("../lib/tobinary.js"),
    exclusions, tests;

// TODO: fix these.
exclusions = [ "€", "¨", "û" ];

tests = {
  setUp: function( done ) {
    done();
  }
};

[
  { char: " ", bin: "00100000" },
  { char: "!", bin: "00100001" },
  { char: "\"", bin: "00100010" },
  { char: "#", bin: "00100011" },
  { char: "$", bin: "00100100" },
  { char: "%", bin: "00100101" },
  { char: "&", bin: "00100110" },
  { char: "'", bin: "00100111" },
  { char: "(", bin: "00101000" },
  { char: ")", bin: "00101001" },
  { char: "*", bin: "00101010" },
  { char: "+", bin: "00101011" },
  { char: ",", bin: "00101100" },
  { char: "-", bin: "00101101" },
  { char: ".", bin: "00101110" },
  { char: "/", bin: "00101111" },
  { char: "0", bin: "00110000" },
  { char: "1", bin: "00110001" },
  { char: "2", bin: "00110010" },
  { char: "3", bin: "00110011" },
  { char: "4", bin: "00110100" },
  { char: "5", bin: "00110101" },
  { char: "6", bin: "00110110" },
  { char: "7", bin: "00110111" },
  { char: "8", bin: "00111000" },
  { char: "9", bin: "00111001" },
  { char: ":", bin: "00111010" },
  { char: ";", bin: "00111011" },
  { char: "<", bin: "00111100" },
  { char: "=", bin: "00111101" },
  { char: ">", bin: "00111110" },
  { char: "?", bin: "00111111" },
  { char: "@", bin: "01000000" },
  { char: "A", bin: "01000001" },
  { char: "B", bin: "01000010" },
  { char: "C", bin: "01000011" },
  { char: "D", bin: "01000100" },
  { char: "E", bin: "01000101" },
  { char: "F", bin: "01000110" },
  { char: "G", bin: "01000111" },
  { char: "H", bin: "01001000" },
  { char: "I", bin: "01001001" },
  { char: "J", bin: "01001010" },
  { char: "K", bin: "01001011" },
  { char: "L", bin: "01001100" },
  { char: "M", bin: "01001101" },
  { char: "N", bin: "01001110" },
  { char: "O", bin: "01001111" },
  { char: "P", bin: "01010000" },
  { char: "Q", bin: "01010001" },
  { char: "R", bin: "01010010" },
  { char: "S", bin: "01010011" },
  { char: "T", bin: "01010100" },
  { char: "U", bin: "01010101" },
  { char: "V", bin: "01010110" },
  { char: "W", bin: "01010111" },
  { char: "X", bin: "01011000" },
  { char: "Y", bin: "01011001" },
  { char: "Z", bin: "01011010" },
  { char: "[", bin: "01011011" },
  { char: "\\", bin: "01011100" },
  { char: "]", bin: "01011101" },
  { char: "^", bin: "01011110" },
  { char: "_", bin: "01011111" },
  { char: "`", bin: "01100000" },
  { char: "a", bin: "01100001" },
  { char: "b", bin: "01100010" },
  { char: "c", bin: "01100011" },
  { char: "d", bin: "01100100" },
  { char: "e", bin: "01100101" },
  { char: "f", bin: "01100110" },
  { char: "g", bin: "01100111" },
  { char: "h", bin: "01101000" },
  { char: "i", bin: "01101001" },
  { char: "j", bin: "01101010" },
  { char: "k", bin: "01101011" },
  { char: "l", bin: "01101100" },
  { char: "m", bin: "01101101" },
  { char: "n", bin: "01101110" },
  { char: "o", bin: "01101111" },
  { char: "p", bin: "01110000" },
  { char: "q", bin: "01110001" },
  { char: "r", bin: "01110010" },
  { char: "s", bin: "01110011" },
  { char: "t", bin: "01110100" },
  { char: "u", bin: "01110101" },
  { char: "v", bin: "01110110" },
  { char: "w", bin: "01110111" },
  { char: "x", bin: "01111000" },
  { char: "y", bin: "01111001" },
  { char: "z", bin: "01111010" },
  { char: "{", bin: "01111011" },
  { char: "|", bin: "01111100" },
  { char: "}", bin: "01111101" },
  { char: "~", bin: "01111110" },
  { char: "€", bin: "10000000" },
  { char: "¡", bin: "10100001" },
  { char: "¢", bin: "10100010" },
  { char: "£", bin: "10100011" },
  { char: "¤", bin: "10100100" },
  { char: "¥", bin: "10100101" },
  { char: "¦", bin: "10100110" },
  { char: "§", bin: "10100111" },
  { char: "¨", bin: "10100111" },
  { char: "©", bin: "10101001" },
  { char: "ª", bin: "10101010" },
  { char: "«", bin: "10101011" },
  { char: "¬", bin: "10101100" },
  // There SHOULD be a soft hyphen here, JSHint won't allow it.
  // So using unicode escape character
  { char: "\u00AD", bin: "10101101" },
  { char: "®", bin: "10101110" },
  { char: "¯", bin: "10101111" },
  { char: "°", bin: "10110000" },
  { char: "±", bin: "10110001" },
  { char: "²", bin: "10110010" },
  { char: "³", bin: "10110011" },
  { char: "´", bin: "10110100" },
  { char: "µ", bin: "10110101" },
  { char: "¶", bin: "10110110" },
  { char: "·", bin: "10110111" },
  { char: "¸", bin: "10111000" },
  { char: "¹", bin: "10111001" },
  { char: "º", bin: "10111010" },
  { char: "»", bin: "10111011" },
  { char: "¼", bin: "10111100" },
  { char: "½", bin: "10111101" },
  { char: "¾", bin: "10111110" },
  { char: "¿", bin: "10111111" },
  { char: "À", bin: "11000000" },
  { char: "Á", bin: "11000001" },
  { char: "Â", bin: "11000010" },
  { char: "Ã", bin: "11000011" },
  { char: "Ä", bin: "11000100" },
  { char: "Å", bin: "11000101" },
  { char: "Æ", bin: "11000110" },
  { char: "Ç", bin: "11000111" },
  { char: "È", bin: "11001000" },
  { char: "É", bin: "11001001" },
  { char: "Ê", bin: "11001010" },
  { char: "Ë", bin: "11001011" },
  { char: "Ì", bin: "11001100" },
  { char: "Í", bin: "11001101" },
  { char: "Î", bin: "11001110" },
  { char: "Ï", bin: "11001111" },
  { char: "Ð", bin: "11010000" },
  { char: "Ñ", bin: "11010001" },
  { char: "Ò", bin: "11010010" },
  { char: "Ó", bin: "11010011" },
  { char: "Ô", bin: "11010100" },
  { char: "Õ", bin: "11010101" },
  { char: "Ö", bin: "11010110" },
  { char: "×", bin: "11010111" },
  { char: "Ø", bin: "11011000" },
  { char: "Ù", bin: "11011001" },
  { char: "Ú", bin: "11011010" },
  { char: "Û", bin: "11011011" },
  { char: "Ü", bin: "11011100" },
  { char: "Ý", bin: "11011101" },
  { char: "Þ", bin: "11011110" },
  { char: "ß", bin: "11011111" },
  { char: "à", bin: "11100000" },
  { char: "á", bin: "11100001" },
  { char: "â", bin: "11100010" },
  { char: "ã", bin: "11100011" },
  { char: "ä", bin: "11100100" },
  { char: "å", bin: "11100101" },
  { char: "æ", bin: "11100110" },
  { char: "ç", bin: "11100111" },
  { char: "è", bin: "11101000" },
  { char: "é", bin: "11101001" },
  { char: "ê", bin: "11101010" },
  { char: "ë", bin: "11101011" },
  { char: "ì", bin: "11101100" },
  { char: "í", bin: "11101101" },
  { char: "î", bin: "11101110" },
  { char: "ï", bin: "11101111" },
  { char: "ð", bin: "11110000" },
  { char: "ñ", bin: "11110001" },
  { char: "ò", bin: "11110010" },
  { char: "ó", bin: "11110011" },
  { char: "ô", bin: "11110100" },
  { char: "õ", bin: "11110101" },
  { char: "ö", bin: "11110110" },
  { char: "÷", bin: "11110111" },
  { char: "ø", bin: "11111000" },
  { char: "ù", bin: "11111001" },
  { char: "ú", bin: "11111010" },
  { char: "û", bin: "11111011" },
  { char: "û", bin: "11111100" },
  { char: "ý", bin: "11111101" },
  { char: "þ", bin: "11111110" },
  { char: "ÿ", bin: "11111111" },


  // Converting "Decimal" values
  //
  { char: 0, bin: "00000000" },
  { char: 1, bin: "00000001" },
  { char: 2, bin: "00000010" },
  { char: 3, bin: "00000011" },
  { char: 4, bin: "00000100" },
  { char: 5, bin: "00000101" },
  { char: 6, bin: "00000110" },
  { char: 7, bin: "00000111" },
  { char: 8, bin: "00001000" },
  { char: 9, bin: "00001001" }

].filter(function( fixture ) {

  return exclusions.indexOf( fixture.char ) === -1;

}).forEach(function( fixture, k ) {

  // console.log( fixture.char, fixture.bin === toBin(fixture.char) );

  tests[ "(#" + k + ") " + fixture.char ] = function( test ) {

    test.expect(1);
    // tests here
    test.equal(
      toBin( fixture.char ), fixture.bin,
      "conversion result matches expected."
    );

    test.done();
  };
});

exports[ "converting" ] = tests;


console.log( toBin("Hello World!") );

/*
  ======== A Handy Little Nodeunit Reference ========
  https://github.com/caolan/nodeunit

  Test methods:
    test.expect(numAssertions)
    test.done()
  Test assertions:
    test.ok(value, [message])
    test.equal(actual, expected, [message])
    test.notEqual(actual, expected, [message])
    test.deepEqual(actual, expected, [message])
    test.notDeepEqual(actual, expected, [message])
    test.strictEqual(actual, expected, [message])
    test.notStrictEqual(actual, expected, [message])
    test.throws(block, [error], [message])
    test.doesNotThrow(block, [error], [message])
    test.ifError(value)
*/
